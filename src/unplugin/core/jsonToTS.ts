import ts from 'typescript'

export async function convertObjectToTypeDefinition(object: any): Promise<ts.TypeElement[]> {
  const typeElements: ts.TypeElement[] = []
  switch (typeof object) {
    case 'object':
      await Promise.all(
        Object.keys(object).map(async (key) => {
          if (typeof object[key] === 'string') {
            const stringValue = object[key]
            // Check if the string contains '%{fooxx}' or '%{bbb}' pattern
            const matches = stringValue.match(/%{([^}]+)}/g)
            if (matches) {
              const variables = matches.map((match: string) =>
                match.substring(2, match.length - 1), // Remove '%{' and '}'
              )
              typeElements.push(
                ts.factory.createPropertySignature(
                  undefined,
                  ts.factory.createStringLiteral(key),
                  undefined,
                  ts.factory.createTypeLiteralNode([
                    ts.factory.createPropertySignature(
                      undefined,
                      ts.factory.createStringLiteral('variables'),
                      undefined,
                      ts.factory.createTypeLiteralNode(
                        variables.map((variable: string) =>
                          ts.factory.createPropertySignature(
                            undefined,
                            ts.factory.createStringLiteral(variable),
                            undefined,
                            ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
                          ),
                        ),
                      ),
                    ),
                  ]),
                ),
              )
            }
            else {
              typeElements.push(
                ts.factory.createPropertySignature(
                  undefined,
                  ts.factory.createStringLiteral(key),
                  undefined,
                  ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
                ),
              )
            }
          }
          else if (typeof object[key] === 'object') {
            const innerTypeElements = await convertObjectToTypeDefinition(object[key])
            typeElements.push(
              ts.factory.createPropertySignature(
                undefined,
                ts.factory.createStringLiteral(key),
                undefined,
                ts.factory.createTypeLiteralNode(innerTypeElements),
              ),
            )
          }
        }),
      )
      return typeElements
  }
  return []
}

export async function createTypesFile(object: any) {
  const sourceFile = ts.createSourceFile(
    'placeholder.ts',
    '',
    ts.ScriptTarget.ESNext,
    true,
    ts.ScriptKind.TS,
  )

  const i18nTranslationsType = ts.factory.createTypeAliasDeclaration(
    [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    ts.factory.createIdentifier('I18nTranslations'),
    undefined,
    ts.factory.createTypeLiteralNode(
      await convertObjectToTypeDefinition(object),
    ),
  )

  const nodes = ts.factory.createNodeArray([
    ts.factory.createImportDeclaration(
      undefined,
      ts.factory.createImportClause(
        false,
        undefined,
        ts.factory.createNamedImports([
          ts.factory.createImportSpecifier(
            false,
            undefined,
            ts.factory.createIdentifier('Path'),
          ),
        ]),
      ),
      ts.factory.createStringLiteral('@productdevbook/ts-i18n'),
      undefined,
    ),
    i18nTranslationsType,
    ts.factory.createTypeAliasDeclaration(
      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
      ts.factory.createIdentifier('I18nPath'),
      undefined,
      ts.factory.createTypeReferenceNode(ts.factory.createIdentifier('Path'), [
        ts.factory.createTypeReferenceNode(
          ts.factory.createIdentifier('I18nTranslations'),
          undefined,
        ),
      ]),
    ),
  ])

  const printer = ts.createPrinter()
  return printer.printList(ts.ListFormat.MultiLine, nodes, sourceFile)
}

export function annotateSourceCode(code: string, header?: string) {
  const eslintDisable = `/* eslint-disable eslint-comments/no-unlimited-disable */
/* eslint-disable */`
  const prettierDisable = `/* prettier-ignore */`
  const tsIgnore = `// @ts-ignore`
  if (header) {
    return `/* DO NOT EDIT, file generated by @productdevbook/ts-i18n */
${header.trim()}

${code}`
  }
  else {
    return `/* DO NOT EDIT, file generated by @productdevbook/ts-i18n */
${eslintDisable}
${prettierDisable}
${tsIgnore}

${code}`
  }
}
